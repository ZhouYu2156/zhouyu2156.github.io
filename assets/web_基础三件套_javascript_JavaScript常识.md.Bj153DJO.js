import{_ as o,c,o as l,aF as i}from"./chunks/framework.DEmh6Vhl.js";const n=JSON.parse('{"title":"JavaScript常识整理","description":"","frontmatter":{},"headers":[],"relativePath":"web/基础三件套/javascript/JavaScript常识.md","filePath":"web/基础三件套/javascript/JavaScript常识.md","lastUpdated":1744689573000}'),d={name:"web/基础三件套/javascript/JavaScript常识.md"};function t(a,e,s,r,p,m){return l(),c("div",null,e[0]||(e[0]=[i('<h1 id="javascript常识整理" tabindex="-1">JavaScript常识整理 <a class="header-anchor" href="#javascript常识整理" aria-label="Permalink to &quot;JavaScript常识整理&quot;">​</a></h1><h2 id="nodejs-默认采用-commonjs-模块化规范" tabindex="-1">nodejs 默认采用 commonjs 模块化规范 <a class="header-anchor" href="#nodejs-默认采用-commonjs-模块化规范" aria-label="Permalink to &quot;nodejs 默认采用 commonjs 模块化规范&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">科普</p><ul><li>(1)每个模块都Node.js 应用由模块组成，每个文件就是一个模块，有自己的作用域。</li><li>(2)在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</li><li>(3)每个模块内部有两个变量可以使用，<code>require</code> 和 <code>module</code>。<code>require</code> 用来加载某个模块，<code>module</code> 代表当前模块，是一个对象，保存了当前模块需要导出的信息。</li><li>(4)<code>exports</code> 是 <code>module</code> 上的一个属性，保存了当前模块要导出的接口或者变量，使用 require 加载的某个模块获取到的值就是那个模块使用 <code>exports</code> 导出的值。</li><li>(5)注意: exports 和 module.exports 是指向同一个对象。最终<code>require</code>加载模块时以<code>module.exports</code>导出的对象为准。重新给<code>exports</code>赋值，相当于<code>exports</code>断掉与<code>module.exports</code>的关联，<code>exports</code>不再指向<code>module.exports</code>，所以实际并不会影响<code>module.exports</code>的导出结果。</li><li>(6)<code>package.json</code>中不显式指定模块规范类型<code>type</code>字段的话，那么在 js 脚本中可以自己选择<code>commonjs</code>模块化方案或者<code>es6</code>模块化规范，在构建时会自动解析，但是不能两种语法混合，否则会报错。</li></ul></div><blockquote><p>总结: <code>commonjs</code>模块化规范规定: 每个模块有独立的空间，互不影响，使用<code>require</code>来引入模块对象，<code>module.exports</code>来导出模块对象，<code>exports</code>全局变量是<code>module.exports</code>的一个引用，如果给<code>exports</code>变量重新赋值，<code>module.exports</code>不会受影响，最终导出结果以<code>module.exports</code>导出的对象为准。</p></blockquote><h2 id="es-modules-esm-模块化规范" tabindex="-1"><code>ES Modules</code>(ESM)模块化规范 <a class="header-anchor" href="#es-modules-esm-模块化规范" aria-label="Permalink to &quot;`ES Modules`(ESM)模块化规范&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">科普</p><ul><li>ECMAScript 2015（ES6）引入了官方的JavaScript模块化标准，称为ES Modules (ESM)。</li><li><code>export</code> 命令用于导出模块的对外接口，<code>import</code> 命令用于导入其他模块导出的内容。</li></ul><p>特点：</p><ul><li>静态结构：ESM的设计是静态的，这意味着你不能根据条件动态地导入或导出模块。所有的导入和导出语句都必须位于模块的顶层，并且它们在代码的解析阶段就已经确定，这支持了编译时优化，如“摇树”优化（<code>Tree Shaking</code>），这种优化可以移除未使用的代码，从而减少最终打包文件的大小。</li><li>实时绑定：ESM导出的是引用，而不是值的复制。这意味着，如果模块内导出的变量值发生了变化，导入该模块的其他模块也能实时获取到最新的值。</li><li>异步加载：ESM支持原生的异步加载模块，使用<code>import()</code>语法可以实现动态导入，这对于按需加载代码、减少初始加载时间非常有用。</li></ul></div><blockquote><p>设计的考虑：</p></blockquote><ul><li>ES6模块：目标是为JavaScript提供一种静态的模块系统，支持编译时优化和更好的静态分析。它的设计鼓励模块的前置声明，使得模块依赖更清晰，也便于各种工具进行分析和打包。</li><li>CommonJS：最初是为服务器环境设计的，考虑到服务器端模块的加载一般不会涉及到网络延迟，因此采用了同步加载的方式。它的设计允许更灵活的模块定义和导出方式，适合Node.js这样的环境。</li></ul><div class="info custom-block"><p class="custom-block-title">对比</p><p>CommonJs和ES Module的区别： CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。</p></div><h2 id="脚手架开发依赖" tabindex="-1">脚手架开发依赖 <a class="header-anchor" href="#脚手架开发依赖" aria-label="Permalink to &quot;脚手架开发依赖&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">推荐</p><ul><li>chalk：控制台字符样式</li><li>commander：node.js命令行接口的完整解决方案</li><li>fs-extra：增强的基础文件操作库</li><li>inquirer：实现命令行之间的交互</li><li>ora：优雅终端Spinner等待动画</li><li>axios：结合Gitlab API获取仓库列表、Tags...</li><li>download-git-repo：从Github/Gitlab中拉取仓库代码</li><li>consolidate ：模板引擎整合库。主要使用ejs实现模板字符替换</li><li>ncp ：像cp -r一样拷贝目录、文件</li><li>metalsmith ：可插入的静态网站生成器；例如获取到根据用户自定义的输入或选择配合ejs渲染变量后的最终内容后，通过它做插入修改。</li><li>semver ：获取库的有效版本号</li><li>ini ：一个用于节点的ini格式解析器和序列化器。主要是对配置做编码和解码。</li><li>jscodeshift ：可以解析文件将代码从AST-to-AST。例如新建一个页面后需要在routes.ts中新建一份路由。</li></ul></div>',11)]))}const S=o(d,[["render",t]]);export{n as __pageData,S as default};
